}
trace (prtms)
prtms(0)
prtms(NA)
is.finite(NULL)
prtms(log(-1))
trace(sum)
hist(stats::rnorm(100)) # shows about 3-4 calls to sum()
untrace(sum)
runif(10)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
# The following function calculates the mean of
# the special "vector" created with the above function. However,
# it first checks to see if the mean has already been calculated.
# If so, it gets the mean from the cache and skips the computation.
# Otherwise, it calculates the mean of the data and sets the value
# of the mean in the cache via the setmean function.
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
pippo<-c(1:20)
mean(pippo)
# debug(makeVector)
pluto<-makeVector(pippo)
str(pluto)
pluto$get
debug(cachemean)
cachemean (pluto)
x
m
m
x
data
m
debug(cachemean)
cachemean (pluto, 1:3)
m
m
pluto$set(pluto)
ls()
y
debug(cachemean)
cachemean (pluto, 1:3)
m
?mean
mean(pippo,  trim = 0.1)
mean(pippo,  trim = 0.2)
mean(pippo,  trim = 0.5)
pippo<-c(1:20,30:10)
mean(pippo,  trim = 0.5)
mean(pippo,  trim = 0.1)
mean(pippo,  trim = 0.2)
mean(pippo,  F)
str(mean)
args(mean)
mean(pippo,  .2)
mean(pippo,  .0)
pluto<-makeVector(pippo)
str(pluto)
pluto$set(pluto)
debug(cachemean)
cachemean (pluto,  0.2)
m
cachemean (pluto)
undebug(cachemean)
pippo<-c(1:20,40:10)
mean(pippo,  .0)
pluto<-makeVector(pippo)
cachemean (pluto)
cachemean (pluto)
cachemean (pluto,.2)
pippo<-c(1:20,20:10)
pluto<-makeVector(pippo)
cachemean (pluto,.2)
cachemean (pluto,.2)
cachemean (pluto)
pippo<-matrix(1:18,3,6)
pippo
1.makeCacheMatrix <- function(x = matrix()) {
dim(x)
if (dim(x[1]!==dim(x[1])){
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix())
{
dim(x)
if (dim(x[1]!==dim(x[1]))
{
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x )
{
dim(x)
if (dim(x[1]!==dim(x[1]))
{
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x )
{
dim(x)
if (dim(x[1]!==dim(x[1])
{
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x= matrix() )
{
dim(x)
if (dim(x[1]!==dim(x[1])
{
message("not square matrix")
return(x)
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x= matrix() )
{
dim(x)
if (dim(x[1]!=dim(x[1])
{
message("not square matrix")
return(x)
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x= matrix() )
{
if (dim(x)[1]!= dim(x)[2])
{
message("not square matrix")
return(x)
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
pippo<-matrix(1:18,3,6)
pippo
makeCacheMatrix <- function(x= matrix() )
{
if (dim(x)[1]!= dim(x)[2])
{
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
pluto<-makeCacheMatrix(pippo)
pluto
pippo<-matrix(1:16,4,4)
pippo
pluto<-makeCacheMatrix(pippo)
pluto
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve (data, ...)
x$setsolve(m)
m
}
pippo<-matrix(1:16,4,4)
pippo
pluto<-makeCacheMatrix(pippo)
pluto
cacheSolve
cacheSolve (pluto)
m
solve(pippo)
pippo<-matrix(c(1:8,8:1),4,4)
pippo
solve(pippo)
?solve
?rnorm
pippo<-matrix(rnorm(16),4,4)
pippo
solve(pippo)
pluto<-makeCacheMatrix(pippo)
pluto
cacheSolve (pluto)
vectorio<-c(1:20)
pluto<-makeCacheMatrix(pippo)
makeCacheMatrix(vectorio)
makeCacheMatrix(c("vectorio"))
## create a special list that contains the basic operations on a matrix:
## set, get, make inverted matrix, get inverted matrix
## the function check if matrix is a square matrix, if not give a
## message and quit it
makeCacheMatrix <- function(x = matrix() )
{
if (dim(x)[1]!= dim(x)[2]) # here check for square matrix
{
message("not square matrix")
return()
}
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(invmtx) m <<- invmtx
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## this function is a child of makeCacheMatrix function
## it check if a named  inverted matrix  is already stored and return it
## or calculate it, store and return it
cacheSolve <- function(x, ...) {
m <- x$getsolve()
if(!is.null(m)) # check if the inverted matrix is already stored
{
message("getting cached data")
return(m)
}
# if no inverted matrix is available get matrix
data <- x$get()
m <- solve (data)
x$setsolve(m)       # invert and store it
m                   # inverted is returned
}
pippo<-matrix(rnorm(16),4,4)
pippo
pippo%*%solve(pippo)
pluto<-makeCacheMatrix(pippo)
pluto
makeCacheMatrix(c("vectorio"))
cacheSolve (pluto)
cacheSolve (pluto)
solve(pippo)
pluto
pippo<-rnorm(25)
pippo
plot(pippo)
hist(pippo)
pippo<-rnorm(50)
pippo
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
pippo<-rnorm(100)
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
pippo<-rnorm(100)
# pippo
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
pippo<-rnorm(100)
# pippo
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
pippo<-rnorm(100)
# pippo
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
pippo<-rnorm(200)
# pippo
plot(pippo)
hist(pippo)
mean(pippo)
sd(pippo)
barplot(table(pippo))
hist(pippo)
?hist
hist(pippo, breaks = "Sturges")
pnorm(2)
summary(y)
set.seed(20)
x<-rnorm(100)
e<-rnorm(100,0,2)
y<-0.5+2x+e
summary(y)
y<- 0.5+2x+e
y<- 0.5+2*x+e
summary(y)
plot(x,y)
set.seed(20)
x<-rbinom(100,1,0.5)
e<-rnorm(100,0,2)
y<- 0.5+2*x+e
summary(y)
plot(x,y)
x
?outer
ls()
cube
f
make.power(2)
make.power<- function(n)
{
pow<-function(x)
{ x^n}
pow
}
make.power(2)
square<-make.power(2)
square(2)
debug(square)
square(2)
x
make.power<- function(elev)
{
pow<-function(x)
{ x^elev}
pow
}
square<-make.power(2)
debug(square)
square(2)
x
elev
cube<-make.pow(3)
cube<-make.power(3)
cube(2)
ls(environment(cube))
get("elev",environment(cube))
get("pow",environment(cube))
y<-10
f<-function(x) {
y<-2
y^2+g(x)
}
g<-function (x) {
x*y
}
f(3)
square
set.seed(1)
rpois(5, 2)
?rpois
set.seed(1)
rpois(5, 2)
dnorm(10)
rnorm(10)
?rbinom
set.seed(1)
rpois(5, 2)
epc<-read.table("household_power_consumption.txt", sep=";",header=T,
# make date/time as a single variable
myTime<-paste(epc$Date, epc$Time)
myT<-strptime(myTime, "%d/%m/%Y %H:%M:%S")
myTime<-paste(epc$Date, epc$Time)
setwd("C:/Users/claudio/SkyDrive/Documents/GitHub/EDA_prj1")
epc<-read.table("household_power_consumption.txt", sep=";",header=T,
# make date/time as a single variable
myTime<-paste(epc$Date, epc$Time)
myT<-strptime(myTime, "%d/%m/%Y %H:%M:%S")
# the file contains ONLY the two days under focus
epc<-read.table("household_power_consumption.txt", sep=";",header=T,
stringsAsFactors = F)
# make date/time as a single variable
myTime<-paste(epc$Date, epc$Time)
myT<-strptime(myTime, "%d/%m/%Y %H:%M:%S")
with (epc, plot(myT,Global_active_power, type="l"))
with (epc,
plot(myT,Global_active_power, type="l",
xlab="Global Active Power (kilowatts)"))
with (epc,
plot(myT,Global_active_power, type="l",
ylab="Global Active Power (kilowatts)", xlab=" "))
png("plot2.png")
with (epc,
plot(myT,Global_active_power, type="l",
ylab="Global Active Power (kilowatts)", xlab=" "))
dev.off()
with (epc, plot(myT,Sub_metering_1, type="l", ))
with (epc, lines(myT,Sub_metering_2, type="l", col = "red"))
with (epc, lines(myT,Sub_metering_3, type="l", col = "Blue"))
legend("topright", legend = c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"),
pch = 1, col = c("black","red", "blue" )  )
with (epc, plot(myT,Sub_metering_1, type="l", ))
with (epc, lines(myT,Sub_metering_2, type="l", col = "red"))
with (epc, lines(myT,Sub_metering_3, type="l", col = "Blue"))
legend("topright", legend = c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"),
pch = 1, col = c("black","red", "blue" )  )
with (epc, plot(myT,Sub_metering_1, type="l",
xlab="", ylab="Energy sub metering"))
with (epc, lines(myT,Sub_metering_2, type="l", col = "red"))
with (epc, lines(myT,Sub_metering_3, type="l", col = "Blue"))
legend("topright", legend = c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"),
pch = 1, col = c("black","red", "blue" )  )
png("plot3.png")
with (epc, plot(myT,Sub_metering_1, type="l",
xlab="", ylab="Energy sub metering"))
with (epc, lines(myT,Sub_metering_2, type="l", col = "red"))
with (epc, lines(myT,Sub_metering_3, type="l", col = "Blue"))
legend("topright", legend = c("Sub_metering_1", "Sub_metering_2", "Sub_metering_3"),
pch = 1, col = c("black","red", "blue" )  )
dev.off()
